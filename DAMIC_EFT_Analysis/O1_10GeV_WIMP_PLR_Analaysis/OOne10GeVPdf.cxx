/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "OOne10GeVPdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "TF1.h" 

ClassImp(OOne10GeVPdf) 

   /*
  /// initialize parameters
  OOne10GeVPdf::OOne10GeVPdf()
  {
  RooRealVar xRV("xRV","x", 0.21, 10.0);
  RooRealVar cofRV("cofRV","cof",0.0, 1.0E-2);
  OOne10GeVPdf("OOne10GeVPdf","OOne10GeVPdf", xRV, cofRV);
  }

/// end of initialize parameters
  */
 OOne10GeVPdf::OOne10GeVPdf(const char *name, const char *title, 
                        ///RooAbsReal& _x,
                        RooAbsReal& _cof) :
   RooAbsPdf(name,title), 
   ///x("x","x",this,_x),
   cof("cof","cof",this,_cof)
 { 
 } 

 OOne10GeVPdf::OOne10GeVPdf(const OOne10GeVPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   ///x("x",this,other.x),
   cof("cof",this,other.cof)
 { 
 } 



Double_t myfunction(Double_t *x, Double_t *par)
   {
      Double_t er = x[0]; /// er is the recoil energy, tmped.
      //Quenching factor
      Double_t SiZ = 14.0; //Z of Silicon.
      Double_t SiA = 28.0; //A of Silicon.
      Double_t epsln = 11.5 * er * TMath::Power(SiZ, -7.0/3.0);
      Double_t gfunction = 3 * TMath::Power(epsln,0.15) + 0.7 * TMath::Power(epsln,0.6) + epsln;
      Double_t kappa = 0.133 * TMath::Power(SiZ,2.0/3.0) / TMath::Sqrt(SiA);
      Double_t qf = kappa * gfunction / (1 + kappa * gfunction);
      Double_t ed  = er * qf ;
 
      ///er = GetX(xx);
      return ed;
   }

Double_t drRO1Si_10(Double_t* x, Double_t* par){/// O1, Silicon, 10 GeV WIMP, 1e-10 pb, 0.6 kg day.

      Double_t ER = x[0],/* wm = par[0], */cof = par[0];

      ///Double_t coeff_1 = 1.15103 * TMath::Power(10,9);
      Double_t coeff_1 = 1.15103 * TMath::Power(10,3);/// decrease from 10^9 to 10^3 "by hands"
      Double_t exprsn_1 = 646.112 * TMath::Exp(-0.00231 * ER);
      Double_t exprsn_2 = (5.42843 * TMath::Power(10,-6) * cof * cof );
      Double_t exprsn_3 = (7.44089 - 0.00736641* ER + 1.33403 * TMath::Power(10, -6) * ER * ER );
      Double_t exprsn_4 = TMath::Erf(1.05455 - 1362.71*(0 + 0.000500317 * TMath::Sqrt(ER) ) );
      Double_t exprsn_5 = TMath::Erf(1.05455 + 1362.71*(0 + 0.000500317 * TMath::Sqrt(ER) ) );

  Double_t drv = coeff_1 * (0. + exprsn_1 * (0. + exprsn_2 * (exprsn_3 * exprsn_3 )) *(exprsn_4 + exprsn_5));

     return drv;
}



 Double_t OOne10GeVPdf::evaluate() const 
 {
/*
  ///  Get the approximate "ER" as an input of "Operator 1" below.     
       TF1 *f1 = new TF1("myfunc",myfunction,0,100,0); /// 100 is big enough, 30 is not.


      Double_t Ed = x, ED = 0.002, firstIdx = 0.4;//"Ed" from data; "ED", original value of iteration.
                                                 /// 10 keV / 100 bins = 0.1 keV / bin.
      Double_t ER = 0. , stp = 1.;
      Int_t idx = 1;

      /// Iteration to get the estimation of "ER" by comparing Ed and ED which evaluated by QF function f1.

 
      while( Ed >= ED ) 
      {
       idx ++;
       stp = double(idx) / 200.0;
       ER = Ed / (firstIdx - stp); /// "firstIdx - stp" is the QF varied with idx.
       ED = f1->Eval(ER);
      }

      delete f1;
 
      ED = 0.002;

      ///Double_t coeff_1 = 2.05541 * TMath::Power(10,7);/// 0.3 Kg*day O1-10GeV, corrected dR/dE from dR/dq.
      Double_t coeff_1 = 5.75515 * TMath::Power(10,8);/// 0.3 Kg*day O1-10GeV
      ///Double_t coeff_1 = 9.59192 * TMath::Power(10,8);/// 0.5 Kg*day O1-10GeV
      ///Double_t coeff_1 = 3.14289 * TMath::Power(10,9);/// 1.6383 Kg*day O1-10GeV
      Double_t exprsn_1 = 646.112 * TMath::Exp(-0.00231 * ER);

      Double_t exprsn_2 = (5.42843 * TMath::Power(10, -6)* cof * cof ) ;
      Double_t exprsn_3 = (7.44089 - 0.00736641* ER + 1.33403 * TMath::Power(10, -6) * ER * ER );

      Double_t exprsn_4 = TMath::Erf(1.05455 - 1362.71*(0 + 0.000500317 * TMath::Sqrt(ER) ) ); ///O1 10GeV
      Double_t exprsn_5 = TMath::Erf(1.05455 + 1362.71*(0 + 0.000500317 * TMath::Sqrt(ER) ) ); ///O1 10GeV

     Double_t f =  coeff_1 * (0. + exprsn_1 * (0. + exprsn_2 * (exprsn_3 * exprsn_3 )) *(exprsn_4 + exprsn_5));
     if(cof == 1.0) cout << endl << "cof = " << cof << ",x = " << x <<  ",f = " << f << endl;
*/
     /// CCD Detection efficiency 
/*      if(Ed <= 0.31 && Ed >= 0)  /// CCD detection efficiency = -0.07 + 3.5Ed.
        return  f / (-0.07 + 3.5*Ed ) + 1.E-50; /// Data * (-0.07 + 3.5Ed) = O1 / (-0.07+3.5Ed).
      else if(Ed > 0.31) /// CCD detection efficiency = 100%.
        return  f + 1.E-50;
      else
       return -1;
*/
      ///cout << "(f + 1.E-50) * ER = " << (f + 1.E-50) * ER << endl;
      ///return  (f + 1.E-50) * ER / 3.; ///very simple integration
    TF1* recspec2nd = new TF1("recspec2nd", drRO1Si_10,0,10,1);
    recspec2nd->SetParameter(0,cof);
    double integralO1 = recspec2nd->Integral(0,10);
    ///cout << endl << "number of events : " << integralO1 << endl;
      return integralO1; 
   
    /*cout << endl << "cof * 1.0 = " << cof * 1.0 << endl;
    return cof * 10.;*/
} 
