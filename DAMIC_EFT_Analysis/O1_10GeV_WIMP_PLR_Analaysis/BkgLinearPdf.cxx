/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "BkgLinearPdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(BkgLinearPdf) 

 BkgLinearPdf::BkgLinearPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _A,
                        RooAbsReal& _B) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   A("A","A",this,_A),
   B("B","B",this,_B)
 { 
 } 

 BkgLinearPdf::BkgLinearPdf(const BkgLinearPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   A("A",this,other.A),
   B("B",this,other.B)
 { 
 } 
/*
 BkgLinearPdf::BkgLinearPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _A,
                        RooAbsReal& _B,
                        RooAbsReal& _cofb) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   A("A","A",this,_A),
   B("B","B",this,_B),
   cofb("cofb","cofb",this,_cofb)
 { 
 } 


 BkgLinearPdf::BkgLinearPdf(const BkgLinearPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   A("A",this,other.A),
   B("B",this,other.B),
   cofb("cofb",this,other.cofb)
 { 
 } 
*/


 Double_t BkgLinearPdf::evaluate() const 
 { 
   ///cout << endl << " A + x*B = " << A + x * B << endl;
   /// CCD Detection efficiency 
/*
      Double_t f = A + x * B;
      if(x <= 0.31 && x >= 0)  /// CCD detection efficiency = -0.07 + 3.5x.
        return f / (-0.07 + 3.5*x ) ; /// Data * (-0.07 + 3.5x) = O1 / (-0.07+3.5x).
      else if(x > 0.31) /// CCD detection efficiency = 100%.
        return  f ;
      else
       return -1;
*/

   // Create the function and wrap it
   TF1 f("Pol 1", "A + x*B", 0, 500);
   ROOT::Math::WrappedTF1 wf1(f);

   // Create the Integrator
   ROOT::Math::GSLIntegrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVE);

   // Set parameters of the integration
   ///ig.SetFunction(wf1, false);
   ig.SetFunction(wf1);
   ig.SetRelTolerance(0.001);

   cout << "Integral bkg: = " << ig.Integral(0,500) << endl;

   return ig.Integral(0,500);

   ///return A + x * B;  

} 
